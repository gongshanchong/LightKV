// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvserver.proto

#include "kvserver.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace kv {
PROTOBUF_CONSTEXPR GetKeyNameResponse::GetKeyNameResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.val_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetKeyNameResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetKeyNameResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetKeyNameResponseDefaultTypeInternal() {}
  union {
    GetKeyNameResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetKeyNameResponseDefaultTypeInternal _GetKeyNameResponse_default_instance_;
PROTOBUF_CONSTEXPR ReqKeyName::ReqKeyName(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.keyrex_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReqKeyNameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqKeyNameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqKeyNameDefaultTypeInternal() {}
  union {
    ReqKeyName _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqKeyNameDefaultTypeInternal _ReqKeyName_default_instance_;
PROTOBUF_CONSTEXPR SetExpireResponse::SetExpireResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flag_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetExpireResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetExpireResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetExpireResponseDefaultTypeInternal() {}
  union {
    SetExpireResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetExpireResponseDefaultTypeInternal _SetExpireResponse_default_instance_;
PROTOBUF_CONSTEXPR ReqExpire::ReqExpire(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.expires_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReqExpireDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqExpireDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqExpireDefaultTypeInternal() {}
  union {
    ReqExpire _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqExpireDefaultTypeInternal _ReqExpire_default_instance_;
PROTOBUF_CONSTEXPR ReqKV::ReqKV(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.val_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.encoding_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReqKVDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqKVDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqKVDefaultTypeInternal() {}
  union {
    ReqKV _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqKVDefaultTypeInternal _ReqKV_default_instance_;
PROTOBUF_CONSTEXPR SetKVResponse::SetKVResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flag_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetKVResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetKVResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetKVResponseDefaultTypeInternal() {}
  union {
    SetKVResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetKVResponseDefaultTypeInternal _SetKVResponse_default_instance_;
PROTOBUF_CONSTEXPR DelKVResponse::DelKVResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.flag_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DelKVResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DelKVResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DelKVResponseDefaultTypeInternal() {}
  union {
    DelKVResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DelKVResponseDefaultTypeInternal _DelKVResponse_default_instance_;
PROTOBUF_CONSTEXPR ReqK::ReqK(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ReqKDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReqKDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReqKDefaultTypeInternal() {}
  union {
    ReqK _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReqKDefaultTypeInternal _ReqK_default_instance_;
PROTOBUF_CONSTEXPR GetKResponse::GetKResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.val_)*/{}
  , /*decltype(_impl_.flag_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetKResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetKResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetKResponseDefaultTypeInternal() {}
  union {
    GetKResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetKResponseDefaultTypeInternal _GetKResponse_default_instance_;
PROTOBUF_CONSTEXPR StreamtreamReqKV::StreamtreamReqKV(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stream_req_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamtreamReqKVDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamtreamReqKVDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamtreamReqKVDefaultTypeInternal() {}
  union {
    StreamtreamReqKV _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamtreamReqKVDefaultTypeInternal _StreamtreamReqKV_default_instance_;
PROTOBUF_CONSTEXPR StreamSetKVResponse::StreamSetKVResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.stream_res_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StreamSetKVResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StreamSetKVResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StreamSetKVResponseDefaultTypeInternal() {}
  union {
    StreamSetKVResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StreamSetKVResponseDefaultTypeInternal _StreamSetKVResponse_default_instance_;
}  // namespace kv
static ::_pb::Metadata file_level_metadata_kvserver_2eproto[11];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_kvserver_2eproto = nullptr;
static const ::_pb::ServiceDescriptor* file_level_service_descriptors_kvserver_2eproto[1];

const uint32_t TableStruct_kvserver_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::GetKeyNameResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::GetKeyNameResponse, _impl_.val_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::ReqKeyName, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::ReqKeyName, _impl_.keyrex_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::SetExpireResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::SetExpireResponse, _impl_.flag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::ReqExpire, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::ReqExpire, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::kv::ReqExpire, _impl_.expires_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::ReqKV, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::ReqKV, _impl_.encoding_),
  PROTOBUF_FIELD_OFFSET(::kv::ReqKV, _impl_.key_),
  PROTOBUF_FIELD_OFFSET(::kv::ReqKV, _impl_.val_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::SetKVResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::SetKVResponse, _impl_.flag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::DelKVResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::DelKVResponse, _impl_.flag_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::ReqK, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::ReqK, _impl_.key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::GetKResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::GetKResponse, _impl_.flag_),
  PROTOBUF_FIELD_OFFSET(::kv::GetKResponse, _impl_.val_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::StreamtreamReqKV, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::StreamtreamReqKV, _impl_.stream_req_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::kv::StreamSetKVResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::kv::StreamSetKVResponse, _impl_.stream_res_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::kv::GetKeyNameResponse)},
  { 7, -1, -1, sizeof(::kv::ReqKeyName)},
  { 14, -1, -1, sizeof(::kv::SetExpireResponse)},
  { 21, -1, -1, sizeof(::kv::ReqExpire)},
  { 29, -1, -1, sizeof(::kv::ReqKV)},
  { 38, -1, -1, sizeof(::kv::SetKVResponse)},
  { 45, -1, -1, sizeof(::kv::DelKVResponse)},
  { 52, -1, -1, sizeof(::kv::ReqK)},
  { 59, -1, -1, sizeof(::kv::GetKResponse)},
  { 67, -1, -1, sizeof(::kv::StreamtreamReqKV)},
  { 74, -1, -1, sizeof(::kv::StreamSetKVResponse)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::kv::_GetKeyNameResponse_default_instance_._instance,
  &::kv::_ReqKeyName_default_instance_._instance,
  &::kv::_SetExpireResponse_default_instance_._instance,
  &::kv::_ReqExpire_default_instance_._instance,
  &::kv::_ReqKV_default_instance_._instance,
  &::kv::_SetKVResponse_default_instance_._instance,
  &::kv::_DelKVResponse_default_instance_._instance,
  &::kv::_ReqK_default_instance_._instance,
  &::kv::_GetKResponse_default_instance_._instance,
  &::kv::_StreamtreamReqKV_default_instance_._instance,
  &::kv::_StreamSetKVResponse_default_instance_._instance,
};

const char descriptor_table_protodef_kvserver_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016kvserver.proto\022\002kv\"!\n\022GetKeyNameRespon"
  "se\022\013\n\003val\030\001 \003(\t\"\034\n\nReqKeyName\022\016\n\006keyRex\030"
  "\001 \001(\t\"!\n\021SetExpireResponse\022\014\n\004flag\030\001 \001(\010"
  "\")\n\tReqExpire\022\013\n\003key\030\001 \001(\t\022\017\n\007expires\030\002 "
  "\001(\004\"3\n\005ReqKV\022\020\n\010encoding\030\001 \001(\r\022\013\n\003key\030\002 "
  "\001(\t\022\013\n\003val\030\003 \001(\t\"\035\n\rSetKVResponse\022\014\n\004fla"
  "g\030\001 \001(\010\"\035\n\rDelKVResponse\022\014\n\004flag\030\001 \001(\010\"\023"
  "\n\004ReqK\022\013\n\003key\030\001 \001(\t\")\n\014GetKResponse\022\014\n\004f"
  "lag\030\001 \001(\010\022\013\n\003val\030\002 \003(\t\"1\n\020StreamtreamReq"
  "KV\022\035\n\nstream_req\030\001 \003(\0132\t.kv.ReqKV\"<\n\023Str"
  "eamSetKVResponse\022%\n\nstream_res\030\001 \003(\0132\021.k"
  "v.SetKVResponse2\257\002\n\010KVServer\022\'\n\005SetKV\022\t."
  "kv.ReqKV\032\021.kv.SetKVResponse\"\000\022%\n\005GetKV\022\010"
  ".kv.ReqK\032\020.kv.GetKResponse\"\000\022&\n\005DelKV\022\010."
  "kv.ReqK\032\021.kv.DelKVResponse\"\000\0223\n\tSetExpir"
  "e\022\r.kv.ReqExpire\032\025.kv.SetExpireResponse\""
  "\000\0226\n\nGetKeyName\022\016.kv.ReqKeyName\032\026.kv.Get"
  "KeyNameResponse\"\000\022>\n\013SetKVStream\022\024.kv.St"
  "reamtreamReqKV\032\027.kv.StreamSetKVResponse\""
  "\000B\003\200\001\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_kvserver_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_kvserver_2eproto = {
    false, false, 774, descriptor_table_protodef_kvserver_2eproto,
    "kvserver.proto",
    &descriptor_table_kvserver_2eproto_once, nullptr, 0, 11,
    schemas, file_default_instances, TableStruct_kvserver_2eproto::offsets,
    file_level_metadata_kvserver_2eproto, file_level_enum_descriptors_kvserver_2eproto,
    file_level_service_descriptors_kvserver_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_kvserver_2eproto_getter() {
  return &descriptor_table_kvserver_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_kvserver_2eproto(&descriptor_table_kvserver_2eproto);
namespace kv {

// ===================================================================

class GetKeyNameResponse::_Internal {
 public:
};

GetKeyNameResponse::GetKeyNameResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.GetKeyNameResponse)
}
GetKeyNameResponse::GetKeyNameResponse(const GetKeyNameResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetKeyNameResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){from._impl_.val_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:kv.GetKeyNameResponse)
}

inline void GetKeyNameResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetKeyNameResponse::~GetKeyNameResponse() {
  // @@protoc_insertion_point(destructor:kv.GetKeyNameResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetKeyNameResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.val_.~RepeatedPtrField();
}

void GetKeyNameResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetKeyNameResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.GetKeyNameResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetKeyNameResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string val = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_val();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "kv.GetKeyNameResponse.val"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetKeyNameResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.GetKeyNameResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string val = 1;
  for (int i = 0, n = this->_internal_val_size(); i < n; i++) {
    const auto& s = this->_internal_val(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.GetKeyNameResponse.val");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.GetKeyNameResponse)
  return target;
}

size_t GetKeyNameResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.GetKeyNameResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string val = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.val_.size());
  for (int i = 0, n = _impl_.val_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.val_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetKeyNameResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetKeyNameResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetKeyNameResponse::GetClassData() const { return &_class_data_; }


void GetKeyNameResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetKeyNameResponse*>(&to_msg);
  auto& from = static_cast<const GetKeyNameResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.GetKeyNameResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.val_.MergeFrom(from._impl_.val_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetKeyNameResponse::CopyFrom(const GetKeyNameResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.GetKeyNameResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetKeyNameResponse::IsInitialized() const {
  return true;
}

void GetKeyNameResponse::InternalSwap(GetKeyNameResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.val_.InternalSwap(&other->_impl_.val_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetKeyNameResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[0]);
}

// ===================================================================

class ReqKeyName::_Internal {
 public:
};

ReqKeyName::ReqKeyName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.ReqKeyName)
}
ReqKeyName::ReqKeyName(const ReqKeyName& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqKeyName* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.keyrex_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.keyrex_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keyrex_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_keyrex().empty()) {
    _this->_impl_.keyrex_.Set(from._internal_keyrex(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:kv.ReqKeyName)
}

inline void ReqKeyName::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.keyrex_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.keyrex_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.keyrex_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqKeyName::~ReqKeyName() {
  // @@protoc_insertion_point(destructor:kv.ReqKeyName)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqKeyName::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keyrex_.Destroy();
}

void ReqKeyName::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqKeyName::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.ReqKeyName)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keyrex_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqKeyName::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string keyRex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_keyrex();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "kv.ReqKeyName.keyRex"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqKeyName::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.ReqKeyName)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string keyRex = 1;
  if (!this->_internal_keyrex().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyrex().data(), static_cast<int>(this->_internal_keyrex().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.ReqKeyName.keyRex");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_keyrex(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.ReqKeyName)
  return target;
}

size_t ReqKeyName::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.ReqKeyName)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string keyRex = 1;
  if (!this->_internal_keyrex().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyrex());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqKeyName::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqKeyName::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqKeyName::GetClassData() const { return &_class_data_; }


void ReqKeyName::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqKeyName*>(&to_msg);
  auto& from = static_cast<const ReqKeyName&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.ReqKeyName)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_keyrex().empty()) {
    _this->_internal_set_keyrex(from._internal_keyrex());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqKeyName::CopyFrom(const ReqKeyName& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.ReqKeyName)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqKeyName::IsInitialized() const {
  return true;
}

void ReqKeyName::InternalSwap(ReqKeyName* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.keyrex_, lhs_arena,
      &other->_impl_.keyrex_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqKeyName::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[1]);
}

// ===================================================================

class SetExpireResponse::_Internal {
 public:
};

SetExpireResponse::SetExpireResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.SetExpireResponse)
}
SetExpireResponse::SetExpireResponse(const SetExpireResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetExpireResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flag_ = from._impl_.flag_;
  // @@protoc_insertion_point(copy_constructor:kv.SetExpireResponse)
}

inline void SetExpireResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetExpireResponse::~SetExpireResponse() {
  // @@protoc_insertion_point(destructor:kv.SetExpireResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetExpireResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetExpireResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetExpireResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.SetExpireResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flag_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetExpireResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetExpireResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.SetExpireResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.SetExpireResponse)
  return target;
}

size_t SetExpireResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.SetExpireResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetExpireResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetExpireResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetExpireResponse::GetClassData() const { return &_class_data_; }


void SetExpireResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetExpireResponse*>(&to_msg);
  auto& from = static_cast<const SetExpireResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.SetExpireResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetExpireResponse::CopyFrom(const SetExpireResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.SetExpireResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetExpireResponse::IsInitialized() const {
  return true;
}

void SetExpireResponse::InternalSwap(SetExpireResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flag_, other->_impl_.flag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetExpireResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[2]);
}

// ===================================================================

class ReqExpire::_Internal {
 public:
};

ReqExpire::ReqExpire(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.ReqExpire)
}
ReqExpire::ReqExpire(const ReqExpire& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqExpire* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.expires_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.expires_ = from._impl_.expires_;
  // @@protoc_insertion_point(copy_constructor:kv.ReqExpire)
}

inline void ReqExpire::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.expires_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqExpire::~ReqExpire() {
  // @@protoc_insertion_point(destructor:kv.ReqExpire)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqExpire::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void ReqExpire::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqExpire::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.ReqExpire)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.expires_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqExpire::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "kv.ReqExpire.key"));
        } else
          goto handle_unusual;
        continue;
      // uint64 expires = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.expires_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqExpire::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.ReqExpire)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.ReqExpire.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // uint64 expires = 2;
  if (this->_internal_expires() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_expires(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.ReqExpire)
  return target;
}

size_t ReqExpire::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.ReqExpire)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // uint64 expires = 2;
  if (this->_internal_expires() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_expires());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqExpire::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqExpire::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqExpire::GetClassData() const { return &_class_data_; }


void ReqExpire::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqExpire*>(&to_msg);
  auto& from = static_cast<const ReqExpire&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.ReqExpire)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (from._internal_expires() != 0) {
    _this->_internal_set_expires(from._internal_expires());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqExpire::CopyFrom(const ReqExpire& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.ReqExpire)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqExpire::IsInitialized() const {
  return true;
}

void ReqExpire::InternalSwap(ReqExpire* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  swap(_impl_.expires_, other->_impl_.expires_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqExpire::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[3]);
}

// ===================================================================

class ReqKV::_Internal {
 public:
};

ReqKV::ReqKV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.ReqKV)
}
ReqKV::ReqKV(const ReqKV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqKV* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.val_){}
    , decltype(_impl_.encoding_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_val().empty()) {
    _this->_impl_.val_.Set(from._internal_val(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.encoding_ = from._impl_.encoding_;
  // @@protoc_insertion_point(copy_constructor:kv.ReqKV)
}

inline void ReqKV::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , decltype(_impl_.val_){}
    , decltype(_impl_.encoding_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.val_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.val_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqKV::~ReqKV() {
  // @@protoc_insertion_point(destructor:kv.ReqKV)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqKV::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
  _impl_.val_.Destroy();
}

void ReqKV::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqKV::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.ReqKV)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _impl_.val_.ClearToEmpty();
  _impl_.encoding_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqKV::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 encoding = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.encoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "kv.ReqKV.key"));
        } else
          goto handle_unusual;
        continue;
      // string val = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_val();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "kv.ReqKV.val"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqKV::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.ReqKV)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 encoding = 1;
  if (this->_internal_encoding() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_encoding(), target);
  }

  // string key = 2;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.ReqKV.key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_key(), target);
  }

  // string val = 3;
  if (!this->_internal_val().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_val().data(), static_cast<int>(this->_internal_val().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.ReqKV.val");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_val(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.ReqKV)
  return target;
}

size_t ReqKV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.ReqKV)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 2;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  // string val = 3;
  if (!this->_internal_val().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_val());
  }

  // uint32 encoding = 1;
  if (this->_internal_encoding() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_encoding());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqKV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqKV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqKV::GetClassData() const { return &_class_data_; }


void ReqKV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqKV*>(&to_msg);
  auto& from = static_cast<const ReqKV&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.ReqKV)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  if (!from._internal_val().empty()) {
    _this->_internal_set_val(from._internal_val());
  }
  if (from._internal_encoding() != 0) {
    _this->_internal_set_encoding(from._internal_encoding());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqKV::CopyFrom(const ReqKV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.ReqKV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqKV::IsInitialized() const {
  return true;
}

void ReqKV::InternalSwap(ReqKV* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.val_, lhs_arena,
      &other->_impl_.val_, rhs_arena
  );
  swap(_impl_.encoding_, other->_impl_.encoding_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqKV::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[4]);
}

// ===================================================================

class SetKVResponse::_Internal {
 public:
};

SetKVResponse::SetKVResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.SetKVResponse)
}
SetKVResponse::SetKVResponse(const SetKVResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetKVResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flag_ = from._impl_.flag_;
  // @@protoc_insertion_point(copy_constructor:kv.SetKVResponse)
}

inline void SetKVResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetKVResponse::~SetKVResponse() {
  // @@protoc_insertion_point(destructor:kv.SetKVResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetKVResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SetKVResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetKVResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.SetKVResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flag_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetKVResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetKVResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.SetKVResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.SetKVResponse)
  return target;
}

size_t SetKVResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.SetKVResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetKVResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetKVResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetKVResponse::GetClassData() const { return &_class_data_; }


void SetKVResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetKVResponse*>(&to_msg);
  auto& from = static_cast<const SetKVResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.SetKVResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetKVResponse::CopyFrom(const SetKVResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.SetKVResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetKVResponse::IsInitialized() const {
  return true;
}

void SetKVResponse::InternalSwap(SetKVResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flag_, other->_impl_.flag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetKVResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[5]);
}

// ===================================================================

class DelKVResponse::_Internal {
 public:
};

DelKVResponse::DelKVResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.DelKVResponse)
}
DelKVResponse::DelKVResponse(const DelKVResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DelKVResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flag_ = from._impl_.flag_;
  // @@protoc_insertion_point(copy_constructor:kv.DelKVResponse)
}

inline void DelKVResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.flag_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DelKVResponse::~DelKVResponse() {
  // @@protoc_insertion_point(destructor:kv.DelKVResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DelKVResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DelKVResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DelKVResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.DelKVResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.flag_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DelKVResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DelKVResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.DelKVResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_flag(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.DelKVResponse)
  return target;
}

size_t DelKVResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.DelKVResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DelKVResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DelKVResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DelKVResponse::GetClassData() const { return &_class_data_; }


void DelKVResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DelKVResponse*>(&to_msg);
  auto& from = static_cast<const DelKVResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.DelKVResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DelKVResponse::CopyFrom(const DelKVResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.DelKVResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DelKVResponse::IsInitialized() const {
  return true;
}

void DelKVResponse::InternalSwap(DelKVResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.flag_, other->_impl_.flag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DelKVResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[6]);
}

// ===================================================================

class ReqK::_Internal {
 public:
};

ReqK::ReqK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.ReqK)
}
ReqK::ReqK(const ReqK& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ReqK* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_key().empty()) {
    _this->_impl_.key_.Set(from._internal_key(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:kv.ReqK)
}

inline void ReqK::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.key_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ReqK::~ReqK() {
  // @@protoc_insertion_point(destructor:kv.ReqK)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReqK::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.key_.Destroy();
}

void ReqK::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReqK::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.ReqK)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReqK::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "kv.ReqK.key"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ReqK::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.ReqK)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.ReqK.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.ReqK)
  return target;
}

size_t ReqK::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.ReqK)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReqK::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReqK::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReqK::GetClassData() const { return &_class_data_; }


void ReqK::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReqK*>(&to_msg);
  auto& from = static_cast<const ReqK&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.ReqK)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _this->_internal_set_key(from._internal_key());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReqK::CopyFrom(const ReqK& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.ReqK)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqK::IsInitialized() const {
  return true;
}

void ReqK::InternalSwap(ReqK* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.key_, lhs_arena,
      &other->_impl_.key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ReqK::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[7]);
}

// ===================================================================

class GetKResponse::_Internal {
 public:
};

GetKResponse::GetKResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.GetKResponse)
}
GetKResponse::GetKResponse(const GetKResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetKResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){from._impl_.val_}
    , decltype(_impl_.flag_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.flag_ = from._impl_.flag_;
  // @@protoc_insertion_point(copy_constructor:kv.GetKResponse)
}

inline void GetKResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.val_){arena}
    , decltype(_impl_.flag_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetKResponse::~GetKResponse() {
  // @@protoc_insertion_point(destructor:kv.GetKResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetKResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.val_.~RepeatedPtrField();
}

void GetKResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetKResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.GetKResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.val_.Clear();
  _impl_.flag_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetKResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool flag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.flag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string val = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_val();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "kv.GetKResponse.val"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetKResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.GetKResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_flag(), target);
  }

  // repeated string val = 2;
  for (int i = 0, n = this->_internal_val_size(); i < n; i++) {
    const auto& s = this->_internal_val(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "kv.GetKResponse.val");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.GetKResponse)
  return target;
}

size_t GetKResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.GetKResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string val = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.val_.size());
  for (int i = 0, n = _impl_.val_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.val_.Get(i));
  }

  // bool flag = 1;
  if (this->_internal_flag() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetKResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetKResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetKResponse::GetClassData() const { return &_class_data_; }


void GetKResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetKResponse*>(&to_msg);
  auto& from = static_cast<const GetKResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.GetKResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.val_.MergeFrom(from._impl_.val_);
  if (from._internal_flag() != 0) {
    _this->_internal_set_flag(from._internal_flag());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetKResponse::CopyFrom(const GetKResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.GetKResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetKResponse::IsInitialized() const {
  return true;
}

void GetKResponse::InternalSwap(GetKResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.val_.InternalSwap(&other->_impl_.val_);
  swap(_impl_.flag_, other->_impl_.flag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetKResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[8]);
}

// ===================================================================

class StreamtreamReqKV::_Internal {
 public:
};

StreamtreamReqKV::StreamtreamReqKV(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.StreamtreamReqKV)
}
StreamtreamReqKV::StreamtreamReqKV(const StreamtreamReqKV& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamtreamReqKV* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stream_req_){from._impl_.stream_req_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:kv.StreamtreamReqKV)
}

inline void StreamtreamReqKV::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stream_req_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamtreamReqKV::~StreamtreamReqKV() {
  // @@protoc_insertion_point(destructor:kv.StreamtreamReqKV)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamtreamReqKV::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stream_req_.~RepeatedPtrField();
}

void StreamtreamReqKV::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamtreamReqKV::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.StreamtreamReqKV)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stream_req_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamtreamReqKV::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .kv.ReqKV stream_req = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stream_req(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamtreamReqKV::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.StreamtreamReqKV)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .kv.ReqKV stream_req = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stream_req_size()); i < n; i++) {
    const auto& repfield = this->_internal_stream_req(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.StreamtreamReqKV)
  return target;
}

size_t StreamtreamReqKV::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.StreamtreamReqKV)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kv.ReqKV stream_req = 1;
  total_size += 1UL * this->_internal_stream_req_size();
  for (const auto& msg : this->_impl_.stream_req_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamtreamReqKV::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamtreamReqKV::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamtreamReqKV::GetClassData() const { return &_class_data_; }


void StreamtreamReqKV::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamtreamReqKV*>(&to_msg);
  auto& from = static_cast<const StreamtreamReqKV&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.StreamtreamReqKV)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stream_req_.MergeFrom(from._impl_.stream_req_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamtreamReqKV::CopyFrom(const StreamtreamReqKV& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.StreamtreamReqKV)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamtreamReqKV::IsInitialized() const {
  return true;
}

void StreamtreamReqKV::InternalSwap(StreamtreamReqKV* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stream_req_.InternalSwap(&other->_impl_.stream_req_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamtreamReqKV::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[9]);
}

// ===================================================================

class StreamSetKVResponse::_Internal {
 public:
};

StreamSetKVResponse::StreamSetKVResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:kv.StreamSetKVResponse)
}
StreamSetKVResponse::StreamSetKVResponse(const StreamSetKVResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StreamSetKVResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.stream_res_){from._impl_.stream_res_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:kv.StreamSetKVResponse)
}

inline void StreamSetKVResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.stream_res_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StreamSetKVResponse::~StreamSetKVResponse() {
  // @@protoc_insertion_point(destructor:kv.StreamSetKVResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StreamSetKVResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.stream_res_.~RepeatedPtrField();
}

void StreamSetKVResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StreamSetKVResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:kv.StreamSetKVResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.stream_res_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StreamSetKVResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .kv.SetKVResponse stream_res = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stream_res(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StreamSetKVResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:kv.StreamSetKVResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .kv.SetKVResponse stream_res = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_stream_res_size()); i < n; i++) {
    const auto& repfield = this->_internal_stream_res(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:kv.StreamSetKVResponse)
  return target;
}

size_t StreamSetKVResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:kv.StreamSetKVResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .kv.SetKVResponse stream_res = 1;
  total_size += 1UL * this->_internal_stream_res_size();
  for (const auto& msg : this->_impl_.stream_res_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StreamSetKVResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StreamSetKVResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StreamSetKVResponse::GetClassData() const { return &_class_data_; }


void StreamSetKVResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StreamSetKVResponse*>(&to_msg);
  auto& from = static_cast<const StreamSetKVResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:kv.StreamSetKVResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.stream_res_.MergeFrom(from._impl_.stream_res_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StreamSetKVResponse::CopyFrom(const StreamSetKVResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:kv.StreamSetKVResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StreamSetKVResponse::IsInitialized() const {
  return true;
}

void StreamSetKVResponse::InternalSwap(StreamSetKVResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.stream_res_.InternalSwap(&other->_impl_.stream_res_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StreamSetKVResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_kvserver_2eproto_getter, &descriptor_table_kvserver_2eproto_once,
      file_level_metadata_kvserver_2eproto[10]);
}

// ===================================================================

KVServer::~KVServer() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* KVServer::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_kvserver_2eproto);
  return file_level_service_descriptors_kvserver_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* KVServer::GetDescriptor() {
  return descriptor();
}

void KVServer::SetKV(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::kv::ReqKV*,
                         ::kv::SetKVResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SetKV() not implemented.");
  done->Run();
}

void KVServer::GetKV(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::kv::ReqK*,
                         ::kv::GetKResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetKV() not implemented.");
  done->Run();
}

void KVServer::DelKV(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::kv::ReqK*,
                         ::kv::DelKVResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method DelKV() not implemented.");
  done->Run();
}

void KVServer::SetExpire(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::kv::ReqExpire*,
                         ::kv::SetExpireResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SetExpire() not implemented.");
  done->Run();
}

void KVServer::GetKeyName(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::kv::ReqKeyName*,
                         ::kv::GetKeyNameResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetKeyName() not implemented.");
  done->Run();
}

void KVServer::SetKVStream(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::kv::StreamtreamReqKV*,
                         ::kv::StreamSetKVResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SetKVStream() not implemented.");
  done->Run();
}

void KVServer::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_kvserver_2eproto[0]);
  switch(method->index()) {
    case 0:
      SetKV(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::kv::ReqKV*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::kv::SetKVResponse*>(
                 response),
             done);
      break;
    case 1:
      GetKV(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::kv::ReqK*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::kv::GetKResponse*>(
                 response),
             done);
      break;
    case 2:
      DelKV(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::kv::ReqK*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::kv::DelKVResponse*>(
                 response),
             done);
      break;
    case 3:
      SetExpire(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::kv::ReqExpire*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::kv::SetExpireResponse*>(
                 response),
             done);
      break;
    case 4:
      GetKeyName(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::kv::ReqKeyName*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::kv::GetKeyNameResponse*>(
                 response),
             done);
      break;
    case 5:
      SetKVStream(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::kv::StreamtreamReqKV*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::kv::StreamSetKVResponse*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& KVServer::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::kv::ReqKV::default_instance();
    case 1:
      return ::kv::ReqK::default_instance();
    case 2:
      return ::kv::ReqK::default_instance();
    case 3:
      return ::kv::ReqExpire::default_instance();
    case 4:
      return ::kv::ReqKeyName::default_instance();
    case 5:
      return ::kv::StreamtreamReqKV::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& KVServer::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::kv::SetKVResponse::default_instance();
    case 1:
      return ::kv::GetKResponse::default_instance();
    case 2:
      return ::kv::DelKVResponse::default_instance();
    case 3:
      return ::kv::SetExpireResponse::default_instance();
    case 4:
      return ::kv::GetKeyNameResponse::default_instance();
    case 5:
      return ::kv::StreamSetKVResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

KVServer_Stub::KVServer_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
KVServer_Stub::KVServer_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
KVServer_Stub::~KVServer_Stub() {
  if (owns_channel_) delete channel_;
}

void KVServer_Stub::SetKV(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::kv::ReqKV* request,
                              ::kv::SetKVResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void KVServer_Stub::GetKV(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::kv::ReqK* request,
                              ::kv::GetKResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void KVServer_Stub::DelKV(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::kv::ReqK* request,
                              ::kv::DelKVResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void KVServer_Stub::SetExpire(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::kv::ReqExpire* request,
                              ::kv::SetExpireResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void KVServer_Stub::GetKeyName(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::kv::ReqKeyName* request,
                              ::kv::GetKeyNameResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void KVServer_Stub::SetKVStream(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::kv::StreamtreamReqKV* request,
                              ::kv::StreamSetKVResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace kv
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::kv::GetKeyNameResponse*
Arena::CreateMaybeMessage< ::kv::GetKeyNameResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::GetKeyNameResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::ReqKeyName*
Arena::CreateMaybeMessage< ::kv::ReqKeyName >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::ReqKeyName >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::SetExpireResponse*
Arena::CreateMaybeMessage< ::kv::SetExpireResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::SetExpireResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::ReqExpire*
Arena::CreateMaybeMessage< ::kv::ReqExpire >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::ReqExpire >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::ReqKV*
Arena::CreateMaybeMessage< ::kv::ReqKV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::ReqKV >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::SetKVResponse*
Arena::CreateMaybeMessage< ::kv::SetKVResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::SetKVResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::DelKVResponse*
Arena::CreateMaybeMessage< ::kv::DelKVResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::DelKVResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::ReqK*
Arena::CreateMaybeMessage< ::kv::ReqK >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::ReqK >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::GetKResponse*
Arena::CreateMaybeMessage< ::kv::GetKResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::GetKResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::StreamtreamReqKV*
Arena::CreateMaybeMessage< ::kv::StreamtreamReqKV >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::StreamtreamReqKV >(arena);
}
template<> PROTOBUF_NOINLINE ::kv::StreamSetKVResponse*
Arena::CreateMaybeMessage< ::kv::StreamSetKVResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::kv::StreamSetKVResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
